/*!
* qrcode-generator (MIT License)
* https://github.com/kazuhikoarase/qrcode-generator
*/
!function(qrcode) {
    function QR8bitByte(data) { this.mode = 1; this.data = data; }
    function QRCode(typeNumber, errorCorrectLevel) {
      this.typeNumber = typeNumber;
      this.errorCorrectLevel = errorCorrectLevel;
      this.modules = null;
      this.moduleCount = 0;
      this.dataCache = null;
      this.dataList = [];
    }
    function QRBitBuffer() { this.buffer = []; this.length = 0; }
    function QRPolynomial(num, shift) {
      if (void 0 == num.length) throw new Error(num.length + "/" + shift);
      for (var offset = 0; offset < num.length && 0 == num[offset];) offset++;
      this.num = new Array(num.length - offset + shift);
      for (var i = 0; i < num.length - offset; i++) this.num[i] = num[i + offset];
    }
    function QRMath() {}
    function QRRSBlock(totalCount, dataCount) {
      this.totalCount = totalCount;
      this.dataCount = dataCount;
    }
    QR8bitByte.prototype = {
      getLength: function() { return this.data.length; },
      write: function(buffer) {
        for (var i = 0; i < this.data.length; i++)
          buffer.put(this.data.charCodeAt(i), 8);
      }
    };
    QRCode.prototype = {
      addData: function(data) {
        var newData = new QR8bitByte(data);
        this.dataList.push(newData);
        this.dataCache = null;
      },
      isDark: function(row, col) {
        if (null == this.modules) throw new Error("QR Code not built yet");
        return this.modules[row][col];
      },
      getModuleCount: function() { return this.moduleCount; },
      make: function() { this.makeImpl(false, this.getBestMaskPattern()); },
      makeImpl: function(test, maskPattern) {
        this.moduleCount = 4 * this.typeNumber + 17;
        this.modules = new Array(this.moduleCount);
        for (var row = 0; row < this.moduleCount; row++) {
          this.modules[row] = new Array(this.moduleCount);
          for (var col = 0; col < this.moduleCount; col++) this.modules[row][col] = null;
        }
        this.setupPositionProbePattern(0, 0);
        this.setupPositionProbePattern(this.moduleCount - 7, 0);
        this.setupPositionProbePattern(0, this.moduleCount - 7);
        this.setupTimingPattern();
        this.setupTypeInfo(test, maskPattern);
        this.dataCache = this.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
        this.mapData(this.dataCache, maskPattern);
      },
      setupPositionProbePattern: function(row, col) {
        for (var r = -1; r <= 7; r++)
          if (!(row + r <= -1 || this.moduleCount <= row + r))
            for (var c = -1; c <= 7; c++)
              if (!(col + c <= -1 || this.moduleCount <= col + c))
                this.modules[row + r][col + c] =
                  r >= 0 && r <= 6 && (0 == c || 6 == c) ||
                  c >= 0 && c <= 6 && (0 == r || 6 == r) ||
                  r >= 2 && r <= 4 && c >= 2 && c <= 4 ? true : false;
      },
      setupTimingPattern: function() {
        for (var i = 8; i < this.moduleCount - 8; i++) {
          null == this.modules[i][6] && (this.modules[i][6] = i % 2 == 0);
          null == this.modules[6][i] && (this.modules[6][i] = i % 2 == 0);
        }
      },
      setupTypeInfo: function(test, maskPattern) {
        var data = (this.errorCorrectLevel << 3 | maskPattern) << 10;
        for (var shift = 0; shift < 10; shift++)
          data ^= QRMath.gexp(QRMath.glog(data));
        for (var i = 0; i < 15; i++) {
          var mod = !test && 1 == (data >> i & 1);
          i < 6 ? this.modules[i][8] = mod :
          i < 8 ? this.modules[i + 1][8] = mod :
          this.modules[this.moduleCount - 15 + i][8] = mod;
          i < 8 ? this.modules[8][this.moduleCount - i - 1] = mod :
          i < 9 ? this.modules[8][15 - i - 1] = mod :
          this.modules[8][this.moduleCount - 15 + i] = mod;
        }
        this.modules[this.moduleCount - 8][8] = !test;
      },
      createData: function(typeNumber, errorCorrectLevel, dataList) {
        // This is a simplified version for brevity. For full support, use the official file.
        var buffer = new QRBitBuffer();
        for (var i = 0; i < dataList.length; i++) {
          var data = dataList[i];
          buffer.put(data.mode, 4);
          buffer.put(data.getLength(), 8);
          data.write(buffer);
        }
        // Padding
        while (buffer.length % 8 != 0) buffer.putBit(false);
        // Add more padding if needed
        while (buffer.length < (4 * typeNumber + 17) * (4 * typeNumber + 17)) buffer.put(0, 8);
        return buffer.buffer;
      },
      mapData: function(data, maskPattern) {
        var inc = -1, row = this.moduleCount - 1, col = this.moduleCount - 1, bitIndex = 7, byteIndex = 0;
        for (; col > 0; col -= 2) {
          6 == col && col--;
          for (; row >= 0 && row < this.moduleCount; row += inc)
            for (var c = 0; c < 2; c++)
              if (null == this.modules[row][col - c]) {
                var dark = false;
                byteIndex < data.length && (dark = 1 == (data[byteIndex] >> bitIndex & 1));
                this.modules[row][col - c] = this.getMask(maskPattern, row, col - c) ? !dark : dark;
                --bitIndex < 0 && (byteIndex++, bitIndex = 7);
              }
          row += inc;
          row >= this.moduleCount && (row = this.moduleCount - 1, inc = -inc);
        }
      },
      getBestMaskPattern: function() {
        var minLostPoint = 1 / 0, pattern = 0;
        for (var i = 0; i < 8; i++) {
          this.makeImpl(true, i);
          var lostPoint = this.getLostPoint();
          lostPoint < minLostPoint && (minLostPoint = lostPoint, pattern = i);
        }
        return pattern;
      },
      getLostPoint: function() {
        var lostPoint = 0;
        for (var row = 0; row < this.moduleCount; row++)
          for (var col = 0; col < this.moduleCount; col++) {
            for (var sameCount = 0, dark = this.isDark(row, col), r = -1; r <= 1; r++)
              if (row + r >= 0 && row + r < this.moduleCount)
                for (var c = -1; c <= 1; c++)
                  col + c >= 0 && col + c < this.moduleCount && !(0 == r && 0 == c) && dark == this.isDark(row + r, col + c) && sameCount++;
            sameCount > 5 && (lostPoint += 3 + sameCount - 5);
          }
        return lostPoint;
      },
      getMask: function(maskPattern, row, col) {
        switch (maskPattern) {
          case 0: return (row + col) % 2 == 0;
          case 1: return row % 2 == 0;
          case 2: return col % 3 == 0;
          case 3: return (row + col) % 3 == 0;
          case 4: return (Math.floor(row / 2) + Math.floor(col / 3)) % 2 == 0;
          case 5: return row * col % 2 + row * col % 3 == 0;
          case 6: return (row * col % 2 + row * col % 3) % 2 == 0;
          case 7: return (row * col % 3 + row + col) % 2 == 0;
          default: throw new Error("bad maskPattern:" + maskPattern);
        }
      }
    };
    QRBitBuffer.prototype = {
      get: function(index) {
        var bufIndex = Math.floor(index / 8);
        return 1 == (this.buffer[bufIndex] >>> 7 - index % 8 & 1);
      },
      put: function(num, length) {
        for (var i = 0; i < length; i++) this.putBit(1 == (num >>> length - i - 1 & 1));
      },
      putBit: function(bit) {
        var bufIndex = Math.floor(this.length / 8);
        this.buffer.length <= bufIndex && this.buffer.push(0);
        bit && (this.buffer[bufIndex] |= 128 >>> this.length % 8);
        this.length++;
      }
    };
    QRPolynomial.prototype = {
        get: function(index) { return this.num[index]; },
        getLength: function() { return this.num.length; },
        multiply: function(e) {
          for (var t = new Array(this.getLength() + e.getLength() - 1), i = 0; i < this.getLength(); i++)
            for (var j = 0; j < e.getLength(); j++)
              t[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
          return new QRPolynomial(t, 0);
        },
        mod: function(e) {
          if (this.getLength() - e.getLength() < 0) return this;
          for (var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0)), num = new Array(this.getLength()), i = 0; i < this.getLength(); i++) num[i] = this.get(i);
          for (var i = 0; i < e.getLength(); i++) num[i] ^= QRMath.gexp(QRMath.glog(e.get(i)) + ratio);
          return new QRPolynomial(num, 0).mod(e);
        }
      };
      QRMath.EXP_TABLE = new Array(256);
      QRMath.LOG_TABLE = new Array(256);
      for (var i = 0; i < 8; i++) QRMath.EXP_TABLE[i] = 1 << i;
      for (var i = 8; i < 256; i++) QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
      for (var i = 0; i < 255; i++) QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
      QRMath.glog = function(n) { if (n < 1) throw new Error("glog(" + n + ")"); return QRMath.LOG_TABLE[n]; };
      QRMath.gexp = function(n) { for (; n < 0;) n += 255; for (; n >= 256;) n -= 255; return QRMath.EXP_TABLE[n]; };
      // The RS block table is omitted for brevity in this snippet. For full version support, use the official file.
      QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
        // This is a stub for basic QR codes. For full support, use the official file.
        return [new QRRSBlock(26, 19)];
      };
      window.QRCode = QRCode;
      }(this);
      // Add QRCode.toCanvas for compatibility with your code
if (!QRCode.toCanvas) {
    QRCode.toCanvas = function(canvas, text, options, cb) {
      if (typeof canvas === "string") canvas = document.getElementById(canvas);
      var qr = new QRCode(1, 1); // typeNumber and errorCorrectLevel are not used in this simple version
      qr.addData(text);
      qr.make();
      var ctx = canvas.getContext("2d");
      var size = options && options.width ? options.width : 200;
      canvas.width = canvas.height = size;
      var cellSize = size / qr.getModuleCount();
      for (var row = 0; row < qr.getModuleCount(); row++) {
        for (var col = 0; col < qr.getModuleCount(); col++) {
          ctx.fillStyle = qr.isDark(row, col) ? (options && options.color && options.color.dark ? options.color.dark : "#000") : (options && options.color && options.color.light ? options.color.light : "#fff");
          ctx.fillRect(Math.round(col * cellSize), Math.round(row * cellSize), Math.ceil(cellSize), Math.ceil(cellSize));
        }
      }
      if (typeof cb === "function") cb();
    };
  }